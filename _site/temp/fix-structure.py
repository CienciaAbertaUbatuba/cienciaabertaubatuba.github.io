import os
import re
import yaml
from pathlib import Path
from unidecode import unidecode
import shutil # For moving directories

# --- Configuration ---
# This is the base directory of your Jekyll site, where folders like 'blog', 'video', etc., exist.
JEKYLL_CONTENT_BASE_DIR = '.'
# List of top-level content directories that were generated by the previous script
# and contain subdirectories that might need their names slugified.
DIRECTORIES_TO_SCAN = ['blog', 'video', 'consulta']
# Individual top-level Markdown files whose parent directory might need renaming if it was derived from a non-slugified name
# (e.g. if 'ciencia-aberta-ubatuba.md' is inside a 'ciencia-aberta-ubatuba' directory)
# For now, we assume these root .md files like 'ciencia-aberta-ubatuba.md' are in slugified directories if they are in one.
# This script primarily focuses on subdirectories within DIRECTORIES_TO_SCAN.

# --- Helper Functions ---

def slugify_path_segment(text_segment):
    if text_segment is None: return "default-slug"
    s = str(text_segment).lower()
    s = unidecode(s)
    s = re.sub(r'\s+', '-', s)
    s = re.sub(r'[^\w\-]', '', s)
    s = re.sub(r'\-{2,}', '-', s)
    s = s.strip('-')
    if not s: return "untitled-segment"
    return s

def is_segment_correctly_slugified(text_segment):
    if not text_segment: return True
    return text_segment == slugify_path_segment(text_segment)

def update_permalink_in_file(md_file_path, new_permalink):
    try:
        with open(md_file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        if content.startswith('---'):
            parts = content.split('---', 2)
            if len(parts) >= 3:
                front_matter_str = parts[1]
                markdown_body = parts[2]
                try:
                    fm = yaml.safe_load(front_matter_str)
                    if fm is None: fm = {} # Handle empty front matter
                    original_permalink = fm.get('permalink')
                    if original_permalink != new_permalink:
                        fm['permalink'] = new_permalink
                        with open(md_file_path, 'w', encoding='utf-8') as f_write:
                            f_write.write('---\n')
                            yaml.dump(fm, f_write, allow_unicode=True, sort_keys=False, Dumper=yaml.SafeDumper)
                            f_write.write('---\n')
                            f_write.write(markdown_body)
                        print(f"    Updated permalink in {md_file_path} to: {new_permalink}")
                    # else:
                        # print(f"    Permalink in {md_file_path} is already correct: {new_permalink}")
                    return True
                except yaml.YAMLError as e:
                    print(f"    YAML Error parsing {md_file_path}: {e}")
            else:
                print(f"    Error: Could not parse front matter in {md_file_path} (no closing '---').")
        else:
            print(f"    Error: No YAML front matter found in {md_file_path}.")
    except Exception as e:
        print(f"    Error processing file {md_file_path}: {e}")
    return False

# --- Main Execution ---
if __name__ == "__main__":
    base_dir = Path(JEKYLL_CONTENT_BASE_DIR).resolve()
    print(f"Starting slug and permalink update in: {base_dir}")
    print(f"Processing top-level directories: {DIRECTORIES_TO_SCAN}")
    print("---REMEMBER TO BACKUP YOUR FILES BEFORE PROCEEDING IF YOU HAVEN'T!---")

    total_dirs_renamed = 0
    total_permalinks_updated = 0

    for dir_to_scan_name in DIRECTORIES_TO_SCAN:
        top_level_dir_path = base_dir / dir_to_scan_name
        if not top_level_dir_path.is_dir():
            print(f"Warning: Directory '{top_level_dir_path}' not found. Skipping.")
            continue

        print(f"\nScanning directory: {top_level_dir_path.relative_to(base_dir)}...")

        # Collect all paths first to avoid issues with os.walk during rename
        paths_to_check = []
        for root_str, dirs, _ in os.walk(top_level_dir_path):
            for d_name in dirs:
                paths_to_check.append(Path(root_str) / d_name)

        # Sort paths by depth (deepest first) to handle nested renames correctly if needed,
        # though this script focuses on leaf content dirs (parent of index.md)
        paths_to_check.sort(key=lambda p: len(p.parts), reverse=True)

        for current_dir_abs_path in paths_to_check:
            index_md_path = current_dir_abs_path / "index.md"
            if not index_md_path.is_file(): # Only process directories that are Jekyll page/post bundles
                continue

            original_dir_name = current_dir_abs_path.name
            slugified_dir_name = slugify_path_segment(original_dir_name)

            new_dir_abs_path = current_dir_abs_path
            if original_dir_name != slugified_dir_name:
                print(f"  Directory needs rename: '{current_dir_abs_path.relative_to(base_dir)}' -> '{slugified_dir_name}'")
                new_dir_abs_path = current_dir_abs_path.with_name(slugified_dir_name)
                try:
                    # Check if target already exists (e.g. from a previous partial run or manual fix)
                    if new_dir_abs_path.exists() and new_dir_abs_path.is_dir():
                        print(f"    Warning: Target directory '{new_dir_abs_path.relative_to(base_dir)}' already exists. Skipping rename of '{original_dir_name}'.")
                        # We still need to update permalink in the existing target dir's index.md
                        index_md_path = new_dir_abs_path / "index.md"
                    else:
                        shutil.move(str(current_dir_abs_path), str(new_dir_abs_path))
                        print(f"    Renamed: '{current_dir_abs_path.relative_to(base_dir)}' to '{new_dir_abs_path.relative_to(base_dir)}'")
                        total_dirs_renamed += 1
                        index_md_path = new_dir_abs_path / "index.md" # Update path to index.md
                except Exception as e:
                    print(f"    Error renaming directory {current_dir_abs_path.relative_to(base_dir)}: {e}")
                    continue # Skip permalink update if rename failed

            # Update permalink in the index.md (whether directory was renamed or not, to ensure consistency)
            if index_md_path.is_file():
                # Expected permalink is based on the path relative to base_dir
                # e.g., if new_dir_abs_path is /path/to/jekyll/blog/2024/01/my-slug
                # then relative path is blog/2024/01/my-slug
                expected_permalink = f"/{new_dir_abs_path.relative_to(base_dir).as_posix()}/"
                if update_permalink_in_file(index_md_path, expected_permalink):
                    total_permalinks_updated +=1 # Count if update_permalink_in_file did something
            else:
                print(f"    Warning: index.md not found in '{new_dir_abs_path.relative_to(base_dir)}' after potential rename.")

    # Special case for video/index.md permalink to be /video/
    video_index_md = base_dir / "video" / "index.md"
    if video_index_md.is_file():
        print(f"\nChecking permalink for {video_index_md.relative_to(base_dir)}...")
        if update_permalink_in_file(video_index_md, "/video/"):
            total_permalinks_updated +=1

    print("\n--- Slug & Permalink Update Complete ---")
    print(f"Directories renamed: {total_dirs_renamed}")
    print(f"Permalinks updated/verified: {total_permalinks_updated}")
    print("Please run 'python audit_jekyll_content.py' again to check the results.")
    print("Next, we will address internal link fixing within Markdown content.")
