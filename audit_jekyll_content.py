import os
import re
import yaml
from pathlib import Path
from urllib.parse import urlparse, unquote
from unidecode import unidecode

# --- Configuration (User might need to adjust these) ---
CONTENT_BASE_DIR = '.' # Assumes script is run from the root of Jekyll site, where content folders like 'blog', 'node' are.
# Define the known top-level directories/file slugs that were generated by the conversion script.
# This helps in reconstructing and validating permalinks.
# Add the slugified name of the 'ciÃªncia-aberta-ubatuba.html' page as well.
KNOWN_CONTENT_ROOT_SLUGS = ['blog', 'node', 'video', 'consulta', 'ciencia-aberta-ubatuba']
# Add other top-level page slugs if they were processed, e.g., 'contact', 'agenda' if they were included later.

# --- Helper Functions ---

def is_slugified(text_segment):
    """Checks if a single path segment is reasonably slugified (ASCII, lowercase, no spaces)."""
    if not text_segment: # Allow empty segments if path ends with /
        return True
    ascii_version = unidecode(text_segment)
    if text_segment != ascii_version.lower(): # Check for case and non-ASCII
        # Allow for already-slugified but originally mixed-case filenames if they are now all lowercase ASCII
        if text_segment.lower() != ascii_version.lower(): # If still different after lowercasing original
             return False
    if ' ' in text_segment:
        return False
    # Check for typical non-slug characters (excluding hyphen, which is allowed)
    # Allow underscore as it's common in slugs sometimes, though hyphens are preferred for Jekyll
    if re.search(r"[^a-z0-9\-_]", text_segment.lower()):
        return False
    return True

def check_path_segments_slugified(path_str):
    """Checks if all segments in a path string are slugified."""
    # remove leading/trailing slashes for splitting, ignore empty segments from that
    # Also handle potential URL parameters or anchors
    path_only = path_str.split('?')[0].split('#')[0]
    return all(is_slugified(segment) for segment in Path(path_only).parts if segment and segment != '/')


# --- Main Audit Logic ---

def audit_markdown_file(file_path, base_dir_path_obj, known_content_roots):
    issues_found = []
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Split front matter and markdown body
        if content.startswith('---'):
            parts = content.split('---', 2)
            if len(parts) >= 3:
                front_matter_str = parts[1]
                markdown_body = parts[2]

                try:
                    fm = yaml.safe_load(front_matter_str)
                except yaml.YAMLError as e:
                    issues_found.append(f"  YAML Error: Could not parse front matter: {e}")
                    fm = None # Ensure fm is defined

                if fm:
                    # 1. Check permalink in front matter
                    if 'permalink' in fm:
                        permalink = fm['permalink']
                        if not isinstance(permalink, str):
                             issues_found.append(f"  Permalink Format: '{permalink}' is not a string.")
                        else:
                            if not permalink.startswith('/'):
                                issues_found.append(f"  Permalink Style: '{permalink}' should be root-relative (start with '/').")
                            if not permalink.endswith('/'):
                                issues_found.append(f"  Permalink Style: '{permalink}' should end with '/' for directory-style URLs.")
                            if not check_path_segments_slugified(permalink):
                                issues_found.append(f"  Permalink Slug: '{permalink}' contains non-slugified segments (check accents, case, spaces).")

                            # Verify permalink matches directory structure
                            expected_path_from_fm = Path(permalink.strip('/'))

                            try:
                                actual_path_from_fs = file_path.parent.relative_to(base_dir_path_obj)
                                if actual_path_from_fs != expected_path_from_fm:
                                    issues_found.append(f"  Permalink vs Path: Mismatch for '{permalink}'. Expected from FS: '/{actual_path_from_fs}/'")
                            except ValueError:
                                if str(file_path.parent.name) != str(expected_path_from_fm):
                                    issues_found.append(f"  Permalink vs Path: Mismatch for top-level page '{permalink}'. Expected from FS: '/{file_path.parent.name}/'")
                    else:
                        issues_found.append("  Front Matter: Missing 'permalink' field.")

                # 2. Check internal links in Markdown body
                internal_links = re.findall(r'\[.*?\]\((?!http)(?!mailto:)(?!tel:)([^)]+)\)', markdown_body)
                for link_href in internal_links:
                    href_to_check = unquote(link_href.split('#')[0].split('?')[0])
                    if href_to_check.endswith(".html"):
                        issues_found.append(f"  Content Link: Points to '.html': [{link_href}]")

                    path_obj = Path(href_to_check)
                    for segment in path_obj.parts:
                        if segment and segment != '/' and segment != '..' and segment != '.':
                            if not is_slugified(segment):
                                issues_found.append(f"  Content Link: Segment '{segment}' in link '[{link_href}]' may not be slugified.")
                                break
            else:
                issues_found.append("  Content: Could not parse front matter (no closing '---').")
        else:
            issues_found.append("  Content: No YAML front matter found.")

    except Exception as e:
        issues_found.append(f"  Processing Error: {e}")
    return issues_found

if __name__ == "__main__":
    base_dir = Path(CONTENT_BASE_DIR).resolve()
    print(f"Starting audit in directory: {base_dir}")
    print(f"Looking for content within subdirectories matching: {KNOWN_CONTENT_ROOT_SLUGS}")
    print("---")

    total_issues = 0
    files_audited = 0

    for content_root_slug_str in KNOWN_CONTENT_ROOT_SLUGS:
        item_path = base_dir / content_root_slug_str

        if item_path.is_dir():
            if not is_slugified(item_path.name): # Check the root slug itself
                print(f"[DIRECTORY WARNING] Top-level content directory name not slugified: '{item_path.name}' (should be '{slugify(item_path.name)}')")
                total_issues +=1

            for root_str, dirs, files in os.walk(item_path):
                current_dir_path = Path(root_str)

                # Check intermediate directory names relative to the current content_root_slug
                if current_dir_path != item_path: # Don't check the KNOWN_CONTENT_ROOT_SLUGS item itself again
                    for part in current_dir_path.relative_to(item_path).parts:
                        if not is_slugified(part):
                            issues_found.append(f"[DIRECTORY WARNING] Subdirectory segment '{part}' in '{current_dir_path.relative_to(base_dir)}' is not slugified.")
                            total_issues += 1
                            break # Only report once per problematic path

                for filename in files:
                    if filename == "index.md":
                        file_full_path = current_dir_path / filename
                        print(f"Auditing: {file_full_path.relative_to(base_dir)}")
                        files_audited += 1
                        issues = audit_markdown_file(file_full_path, base_dir, KNOWN_CONTENT_ROOT_SLUGS)
                        if issues:
                            for issue in issues:
                                print(issue)
                            total_issues += len(issues)
                        else:
                            print("  No issues found.")
        elif (item_path / "index.md").is_file(): # Case for slugified top-level files that became dirs
            file_full_path = item_path / "index.md"
            print(f"Auditing: {file_full_path.relative_to(base_dir)}")
            files_audited += 1
            issues = audit_markdown_file(file_full_path, base_dir, KNOWN_CONTENT_ROOT_SLUGS)
            if issues:
                for issue in issues:
                    print(issue)
                total_issues += len(issues)
            else:
                print("  No issues found.")
        # else: # This would be for top-level .html files that were NOT converted to dir/index.md structure
            # print(f"[INFO] Configured content root '{content_root_slug_str}' not found as a directory or page container (dir/index.md).")


    print("\n--- Audit Complete ---")
    print(f"Files Audited: {files_audited}")
    print(f"Total Potential Issues Found: {total_issues}")
    if total_issues > 0:
        print("\nPlease review the warnings above. This script does not modify any files.")
    else:
        print("Looks good from this basic audit!")
